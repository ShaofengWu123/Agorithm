#include <stdio.h>
#include "Arrayops.h"

#define NPoints 6
#define Inf 1000

//Dijkstra算法的本质：从最短的前驱路径开始，第一轮循环看由此路径到达其他点的长度并记录各点的路径最短长度和前驱节点，
//                  并同时确定一个第二短前驱路径(当前各点最短长度最小值，原因是它是最小值，其他的未确定点当前最短长度都比这个长，从其他点最短路径接着走过去一定长于它)，继续循环。
//                  之后的每次循环，都能从上次的最短前驱路径确定好一个”第二“短前驱路径（这轮循环未确定节点的最短路径最小值），这个”第二“短前驱路径来源于已确定的最短前驱路径、第二短前驱路径、第三短前驱路径...、上次的最短前驱路径中的一条，在比较的时候，实际上是在比较1、来源于最短前驱路径、第二短前驱路径、第三短前驱路径...的最短结果（路径长度在之前的循环中被储存好了，对应前驱节点也被储存好了）和2、上次最短路径到该节点的最短结果（即直接用上次最短路径尾节点和该节点相连的结果），并由更小的值作为最终值
//证明Dijkstra算法的有效性使用数学归纳法即可

//时间复杂度：O(V(G)^2)，NPoints-1次循环，每次循环最多计算比较NPoints-1个点的新路径与已知最短路径
int main() {
	//初始化图，这里的具体数据来自图论Dijkstra算法习题chap1.26
	
	int path[NPoints][NPoints] = 
	{0,  50, Inf, 40, 25, 10,
	 50,0,   15, 20, Inf, 25,   
	 Inf,15, 0,   10, 20, Inf,
	40, 20, 10, 0,   10, 25,
	25, Inf, 20, 10, 0,  55,
	10,25,   Inf, 25, 55, 0,
	};
	int d[NPoints] = {0,Inf,Inf,Inf,Inf,Inf,};//当前到各点的最短路径
	int L[NPoints] = {-1,-1,-1,-1,-1,-1};//各点最点距离的前驱节点
	int S[NPoints] = {1,0,0,0,0,0,};//标识各点是否已经确定好最短路径
	int prior = 0;
	//开始循环,共需要NPoints-1次循环
	for (int i = 0; i < NPoints - 1; i++) {

		int MIN = Inf;
		int MIN_index=0;
		for (int j = 0; j < NPoints; j++) {//进行NPoints-1次循环，但是有i+1个点已经确定好了最短路径，所以只有NPoints-i-2次循环会进入if语句计算新路径并与已知最短路径比较
			
			if (!S[j]) {//即j对应点还没有确定好最短路径，在S数组内用0标记表示没有确定好最短路径。
				if (d[prior] + path[prior][j]<d[j]) {//比较已知最短路径与新路径，若新路径更短那么更新已知最短路径，否则什么也不做
					d[j] = d[prior] + path[prior][j];
					L[j] = prior;
				}
				//实时更新V-S中最小路径的值，以便作为下次路径延伸的开始地点
				if (min(MIN, d[j]) == d[j]) { MIN = d[j]; MIN_index = j; }
			}
			else { ; }

		}

		printf("到%d节点的最短路径长度是%d，前驱节点是%d\n",MIN_index,d[MIN_index],L[MIN_index]);
		prior = MIN_index; S[MIN_index] = 1;//MIN_index对应点最短路径计算完成，作为下一次循环路径延伸的开始点

	}

	return 0;
}